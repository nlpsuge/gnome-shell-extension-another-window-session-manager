'use strict';


const { Gio, GLib } = imports.gi

const ExtensionUtils = imports.misc.extensionUtils;
const Me = ExtensionUtils.getCurrentExtension();

var default_sessionName = 'defaultSession';
const home_dir = GLib.get_home_dir();
// This extension can restore `xsm`'s session file, 
// but desktop_file_id is missing in that file, so can't move them. Will be fixed in the future.
const config_path_base = GLib.build_filenamev([home_dir, '.config', 'another-window-session-manager']);
var sessions_path = GLib.build_filenamev([config_path_base, 'sessions']);
var sessions_backup_folder_name = 'backups';
var sessions_backup_path = GLib.build_filenamev([sessions_path, sessions_backup_folder_name]);

let projectPath;
try {
    projectPath = Me.path;
} catch (e) {
    projectPath = './'
    logError(e);
}
var desktop_template_path = GLib.build_filenamev([projectPath, '/template/template.desktop']);

// Add __ to make it look like generated by a program, users don't want to touch it
var desktop_file_store_path = '~/.local/share/applications/__another-window-session-manager';

function get_sessions_path() {
    return sessions_path;
}

function get_sessions_backups_path() {
    return sessions_backup_path;
}

function getJsonObj(contents) {
    let session_config;
    // Fix Gnome 3 crash due to: Some code called array.toString() on a Uint8Array instance. Previously this would have interpreted the bytes of the array as a string, but that is nonstandard. In the future this will return the bytes as comma-separated digits. For the time being, the old behavior has been preserved, but please fix your code anyway to explicitly call ByteArray.toString(array).
    if (contents instanceof Uint8Array) {
        const contentsConverted = imports.byteArray.toString(contents);
        session_config = JSON.parse(contentsConverted);
    } else {
        // Unreachable code
        session_config = JSON.parse(contents);
    }
    return session_config;
}

function listAllSessions(sessionPath, recursion, debug, callback) {
    if (!sessionPath) {
        sessionPath = get_sessions_path();
    }
    if (!GLib.file_test(sessionPath, GLib.FileTest.EXISTS)) {
        logError(new Error(`${sessionPath} not exist`));
        return;
    }

    if (debug) {
        log(`Looking up path: ${sessionPath}`);
    }
    const sessionPathFile = Gio.File.new_for_path(sessionPath);
    let fileEnumerator;
    try {
        fileEnumerator = sessionPathFile.enumerate_children(
            [Gio.FILE_ATTRIBUTE_STANDARD_NAME, 
                Gio.FILE_ATTRIBUTE_STANDARD_TYPE, 
                Gio.FILE_ATTRIBUTE_TIME_MODIFIED,
                Gio.FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE].join(','),
            Gio.FileQueryInfoFlags.NONE,
            null);
    } catch(e) {
        logError(e, `Failed to list directory ${sessionPath}`);
        fileEnumerator = null;
    }

    if (fileEnumerator != null) {
        let info;
        while ((info = fileEnumerator.next_file(null))) {
            const file = fileEnumerator.get_child(info);
            if (recursion && info.get_file_type() === Gio.FileType.DIRECTORY) {
                if (debug) {
                    log(`${info.get_name()} is a folder, checking`);
                }
                listAllSessions(file.get_path(), recursion, debug, callback);
            }

            if (callback) {
                callback(file, info);
            }
        }
    }
    
}

function trashSession(sessionName) {
    const sessionFilePath = GLib.build_filenamev([sessions_path, sessionName]);
    if (!GLib.file_test(sessionFilePath, GLib.FileTest.EXISTS)) {
        return true;
    }
    
    let trashed = false;
    try {
        const sessionPathFile = Gio.File.new_for_path(sessionFilePath);
        trashed = sessionPathFile.trash(null);
        if (!trashed) {
            logError(new Error(`Failed to trash file ${sessionFilePath}. Reason: Unknown.`));
        }
        return trashed;
    } catch(e) {
        logError(e, `Failed to trash file ${sessionFilePath}`);
        return false;
    }
}

function isDirectory(sessionName) {
    const sessionFilePath = GLib.build_filenamev([sessions_path, sessionName]);
    if (GLib.file_test(sessionFilePath, GLib.FileTest.IS_DIR)) {
        return true;
    }

    return false;
}

function loadDesktopTemplate() {
    const desktop_template_file = Gio.File.new_for_path(desktop_template_path);
    let [success, contents] = desktop_template_file.load_contents(null);
    if (success) {
        return contents;
    }

    return '';
}

function desktopFileIsExisting(desktopFileName) {
    const desktopFilePath = GLib.build_filenamev([desktop_template_path, desktopFileName]);
    return GLib.file_test(desktopFilePath, GLib.FileTest.EXISTS);
}

/**
 * 
 * Create a generated .desktop based on the template/template.desktop
 * when it doesn't exist.
 * 
 * The .desktop file is in ~/.local/share/applications
 * 
 * If the generated .desktop is not working, please report it to the issues area.
 * 
 * @param {string} desktopFileName  The .desktop file name
 * @param {object} argument         To be used to fill the template/template.desktop 
 * @returns {Array}                 An array that contains three value. 
 *                                  1) true if create a .desktop file successfully, otherwise false 
 *                                  2) true if the .desktop file has already been existing, otherwise falsy
 *                                  3) the reason why the first or two are falsy
 */
function writeDesktopFileIfNecessary(desktopFileName, argument) {
    const desktopFilePath = GLib.build_filenamev([desktop_template_path, desktopFileName]);
    if(!GLib.file_test(desktopFilePath, GLib.FileTest.EXISTS)) {
        if (!GLib.mkdir_with_parents(desktop_template_path, 0o744) === 0) {
            const errMsg = `Failed to create necessary folders for the .desktop file ${desktopFileName} using ${JSON.stringify(argument)}`;
            logError(errMsg);
            return [false, false, errMsg];
        }

        const desktopFileContent = loadDesktopTemplate().format(argument);
            if (!desktopFileContent) {
                const errMsg = `Failed to generate a .desktop file ${desktopFileName} using ${JSON.stringify(argument)}`;
                logError(errMsg);
                return [false, false, errMsg];
            }

            const desktopFile = Gio.File.new_for_path(desktopFilePath);
            let [success, tag] = desktopFile.replace_contents(
                desktopFileContent,
                null,
                false,
                Gio.FileCreateFlags.REPLACE_DESTINATION,
                null
            );
           return [success];
    } else {
        const desktopFileExisting = true;
        return [false, desktopFileExisting, `${desktopFileName} has been existing`];
    }

    return [false];
}

// tests

// test writeDesktopFileIfNecessary() // test is not working
const argument = {
    appName: "Anki",
    commandLine: 'anki --no-sandbox -b /tmp/anki',
    icon: '',
    wmClass: 'Anki',
    wmClassInstance: 'anki',
};
const desktopFileName = '__Anki.desktop';
// writeDesktopFileIfNecessary(desktopFileName, argument);


// test listAllSessions()
// let index = 0;
// listAllSessions(null, false, (file, info) => {
//     if (info.get_file_type() === Gio.FileType.REGULAR) {
//         let parent = file.get_parent();
//         let parentPath;
//         if (parent === null) {
//             // Impossible in the case
//             parentPath = '/';
//         } else {
//             parentPath = parent.get_path();
//         }
//         log(`Processing ${file.get_path()} under ${parentPath}. ${index++}`);
//     }
// });
